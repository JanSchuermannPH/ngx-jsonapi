{"version":3,"file":"noduplicatedhttpcalls.service.js","sourceRoot":"","sources":["../../src/services/noduplicatedhttpcalls.service.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AAE9C,MAAM;;qBACuD,EAAE;;;;;;IAEpD,WAAW,CAAC,IAAY;QAC3B,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC;;;;;;IAGjB,WAAW,CAAC,IAAY;;YACjC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACxB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;aACzB;YAED,qBAAI,QAAQ,GAAkB,IAAI,QAAQ,EAAE,CAAC;;YAE7C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAEhC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC;;;;;;;;IAGf,iBAAiB,CAAC,IAAY,EAAE,OAAqB;;YAC9D,OAAO;iBACF,IAAI,CAAC,OAAO;gBACT,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;oBACrB,GAAG,CAAC,CAAC,qBAAI,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBACpC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;qBAC7B;oBACD,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;iBAC3B;aACJ,CAAC;iBACD,KAAK,CAAC,KAAK;gBACR,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;oBACrB,GAAG,CAAC,CAAC,qBAAI,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBACpC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;qBAC1B;oBACD,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;iBAC3B;aACJ,CAAC,CAAC;;;CAEd","sourcesContent":["import { Deferred } from '../shared/deferred';\n\nexport class NoDuplicatedHttpCallsService {\n    public calls: { [path: string]: Array<Deferred<any>> } = {};\n\n    public hasPromises(path: string) {\n        return path in this.calls;\n    }\n\n    public async getAPromise(path: string): Promise<any> {\n        if (!(path in this.calls)) {\n            this.calls[path] = [];\n        }\n\n        let deferred: Deferred<any> = new Deferred();\n        // let deferred = this.$q.defer();\n        this.calls[path].push(deferred);\n\n        return deferred.promise;\n    }\n\n    public async setPromiseRequest(path: string, promise: Promise<any>) {\n        promise\n            .then(success => {\n                if (path in this.calls) {\n                    for (let promise2 of this.calls[path]) {\n                        promise2.resolve(success);\n                    }\n                    delete this.calls[path];\n                }\n            })\n            .catch(error => {\n                if (path in this.calls) {\n                    for (let promise2 of this.calls[path]) {\n                        promise2.reject(error);\n                    }\n                    delete this.calls[path];\n                }\n            });\n    }\n}\n"]}